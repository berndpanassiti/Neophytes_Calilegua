---
title: "workingdata"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
load("data/workingdata.RData")
library(ggplot2)
library(tidyverse)
```








# Ordination - PCA
```{r}
dat=speciesPercentSite
dat= dat %>% remove_rownames %>% column_to_rownames(var="site_id") # library tidyverse
PCA <- rda(dat, scale = FALSE)
# Use scale = TRUE if your variables are on different scales (e.g. for abiotic variables).
# Here, all species are measured on the same scale 
# So use scale = FALSE

# Now plot a bar plot of relative eigenvalues. This is the percentage variance explained by each axis
barplot(as.vector(PCA$CA$eig)/sum(PCA$CA$eig)) 
# How much of the variance in our dataset is explained by the first principal component?

# Calculate the percent of variance explained by first two axes
sum((as.vector(PCA$CA$eig)/sum(PCA$CA$eig))[1:2]) # 97%, this is ok.
# Also try to do it for the first three axes

# Now, we`ll plot our results with the plot function
plot(PCA)
plot(PCA, display = "sites", type = "points")
plot(PCA, display = "species", type = "text")
```










# Ordination - NMDS

metaMDS automatically applies a square root transformation and calculates Bray-Curtis distances

```{r}
# First step is to calculate a distance matrix. See PCOA for more information about the distance measures
# Here we use bray-curtis distance, which is recommended for abundance data
dist <- vegdist(veg,  method = "bray")

# In this part, we define a function NMDS.scree() that automatically 
# performs a NMDS for 1-10 dimensions and plots the nr of dimensions vs the stress
NMDS.scree <- function(x) { #where x is the name of the data frame variable
  plot(rep(1, 10), replicate(10, metaMDS(x, autotransform = F, k = 1)$stress), xlim = c(1, 10),ylim = c(0, 0.30), xlab = "# of Dimensions", ylab = "Stress", main = "NMDS stress plot")
  for (i in 1:10) {
    points(rep(i + 1,10),replicate(10, metaMDS(x, autotransform = F, k = i + 1)$stress))
  }
}

# Use the function that we just defined to choose the optimal nr of dimensions
NMDS.scree(dist)
```


```{r}
# Because the final result depends on the initial 
# random placement of the points 
# we`ll set a seed to make the results reproducible
set.seed(2)

# Here, we perform the final analysis and check the result
NMDS1 <- metaMDS(dist, k = 2, trymax = 100, trace = F)
# Do you know what the trymax = 100 and trace = F means?
# Let's check the results
NMDS1


# If you don`t provide a dissimilarity matrix, metaMDS automatically applies Bray-Curtis. So in our case, the results would have to be the same
NMDS2 <- metaMDS(veg, k = 2, trymax = 100, trace = F)
NMDS2
```




```{r}
NMDS3 <- metaMDS(veg, k = 2, trymax = 100, trace = F, autotransform = FALSE, distance="bray")



# Alternatively, you can use the functions ordiplot and orditorp
ordiplot(NMDS3, type = "n")
orditorp(NMDS3, display = "species", col = "red", air = 0.01)
orditorp(NMDS3, display = "sites", cex = 1.1, air = 0.01)
```

## Inlcude environment
```{r}
# The function envfit will add the environmental variables as vectors to the ordination plot
ef <- envfit(NMDS3, env, permu = 999)
ef


# The two last columns are of interest: the squared correlation coefficient and the associated p-value
# Plot the vectors of the significant correlations and interpret the plot
plot(NMDS3, type = "t", display = "species")
#plot(ef, p.max = 0.05)
plot(ef)
```








































https://cran.r-project.org/web/packages/vegdata/vignettes/vegdata.pdf

a “Nonmetric Multidimensional Scaling with Stable Solution from Random Starts
Axis Scaling and Species Scores” which is a wrapper for Kruskal’s Non-metric Multidimensional Scaling [Cox and Cox, 1994, 2001] from Jari Oksanen [Oksanen et al., 2008].

```{r}
## Data analyses
library(vegan)

veg.nmds <- metaMDS(elbaue, distance = "bray", trymax = 5, autotransform =FALSE,
noshare = 1, expand = TRUE, trace = 2)
#eco <- tv.traits()
#eco£OEK_F <- as.numeric(eco£OEK_F)
F <- isc(elbaue, trait.db = 'ecodbase.dbf', ivname = 'OEK_F', method = 'mean')
N <- isc(elbaue, trait.db = 'ecodbase.dbf', ivname = 'OEK_N', method = 'mean')
env <- envfit(veg.nmds, env = data.frame(F, N))
```


To show the result in comparison with environmental measurements in a nice graphic we do some plotting
magic.

```{r}
library(labdsv)
Loading required package: mgcv
Loading required package: nlme
This is mgcv 1.8-30. For overview type ’help("mgcv-package")’.
This is labdsv 2.0-1
convert existing ordinations with as.dsvord()
Attaching package: ’labdsv’
The following object is masked from ’package:stats’:
density
library(akima)
color = function(x)rev(topo.colors(x))
nmds.plot <- function(ordi, site, var1, var2, disp, plottitle = 'NMDS', env = NULL, ...) {
lplot <- nrow(ordi$points); lspc <- nrow(ordi$species)
filled.contour(interp(ordi$points[, 1], ordi$points[, 2], site[, var1]),
ylim = c(-1, 1.1), xlim = c(-1.4, 1.4),
color.palette = color, xlab = var1, ylab = var2, main = plottitle,
key.title = title(main = var1, cex.main = 0.8, line = 1, xpd = NA),
plot.axes = { axis(1); axis(2)
points(ordi$points[, 1], ordi$points[, 2], xlab = "", ylab = "", cex= .5, col = 2, pch = '+')
points(ordi$species[, 1], ordi$species[, 2], xlab = "", ylab = "", cex=.2, pch = 19)
ordisurf(ordi, site[, var2], col = 'black', choices = c(1, 2), add = TRUE)
orditorp(ordi, display = disp, pch = " ")
legend("topright", paste("GAM of ", var2), col = 'black', lty = 1)
if(!is.null(env)) plot(env, col='red')
}
,...)
}



nmds.plot(veg.nmds, elbaue.env, disp='species', var1="MGL", var2="SDGL", env=env, plottitle = 'Elbaue floodplain dataset')

```





